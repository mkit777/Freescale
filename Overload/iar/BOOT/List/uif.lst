###############################################################################
#
# IAR ANSI C/C++ Compiler V8.20.2.14835/W32 for ARM       08/Mar/2018  21:10:25
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  D:\workspace\LPLD_OSKinetis_V3\lib\common\uif.c
#    Command line =  
#        -f C:\Users\JoyC\AppData\Local\Temp\EWD72B.tmp
#        (D:\workspace\LPLD_OSKinetis_V3\lib\common\uif.c -D LPLD_K60 -D
#        USE_K60DZ10 -lCN
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\BOOT\List -lB
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\BOOT\List -o
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\BOOT\Obj --no_cse
#        --no_unroll --no_inline --no_code_motion --no_tbaa --no_clustering
#        --no_scheduling --debug --endian=little --cpu=Cortex-M4 -e --fpu=None
#        --dlib_config "D:\Program Files\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\app\ -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\CPU\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\common\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\LPLD\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\LPLD\HW\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\LPLD\FUNC\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\FatFs\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\FatFs\option\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\USB\common\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\USB\driver\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\USB\descriptor\
#        -I
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\..\..\..\lib\USB\class\
#        -Ol -I "D:\Program Files\IAR Systems\Embedded Workbench
#        8.0\arm\CMSIS\Include\" -D ARM_MATH_CM4)
#    Locale       =  C
#    List file    =  
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\BOOT\List\uif.lst
#    Object file  =  
#        D:\workspace\LPLD_OSKinetis_V3\project\Overload\iar\BOOT\Obj\uif.o
#
###############################################################################

D:\workspace\LPLD_OSKinetis_V3\lib\common\uif.c
      1          /**
      2           * @file uif.c
      3           * @version 3.0[By LPLD]
      4           * @date 2013-06-18
      5           * @brief 提供简单的交互接口
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * The commands, set/show parameters, and prompt are configured 
     10           * at the project level
     11           *
     12           * 版权所有:北京拉普兰德电子技术有限公司
     13           * http://www.lpld.cn
     14           * mail:support@lpld.cn
     15           *
     16           * @par
     17           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     18           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     19           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     20           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     21           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     22           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     23           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     24           */
     25          
     26          #include "common.h"
     27          #include "uif.h"
     28          
     29          /********************************************************************/
     30          /*
     31           * Global messages -- constant strings
     32           */

   \                                 In section .rodata, align 4
     33          const int8 HELPMSG[] =
   \                     HELPMSG:
   \   00000000   0x45 0x6E          DC8 "Enter 'help' for help.\012"
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x27 0x68    
   \              0x65 0x6C    
   \              0x70 0x27    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x68    
   \              0x65 0x6C    
   \              0x70 0x2E    
   \              0x0A 0x00    
     34              "Enter 'help' for help.\n";
     35          

   \                                 In section .rodata, align 4
     36          const int8 INVARG[] =
   \                     INVARG:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     37              "Error: Invalid argument: %s\n";
     38          

   \                                 In section .rodata, align 4
     39          const int8 INVALUE[] = 
   \                     INVALUE:
   \   00000000   0x45 0x72          DC8 "Error: Invalid value: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x76    
   \              0x61 0x6C    
   \              0x75 0x65    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0
     40              "Error: Invalid value: %s\n";
     41          
     42          /*
     43           * Strings used by this file only
     44           */

   \                                 In section .rodata, align 4
     45          static const int8 INVCMD[] =
   \                     INVCMD:
   \   00000000   0x45 0x72          DC8 "Error: No such command: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x73 0x75    
   \              0x63 0x68    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
     46              "Error: No such command: %s\n";
     47          

   \                                 In section .rodata, align 4
     48          static const int8 HELPFORMAT[] = 
   \                     HELPFORMAT:
   \   00000000   0x25 0x38          DC8 "%8s  %-25s %s %s\012"
   \              0x73 0x20    
   \              0x20 0x25    
   \              0x2D 0x32    
   \              0x35 0x73    
   \              0x20 0x25    
   \              0x73 0x20    
   \              0x25 0x73    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0
     49              "%8s  %-25s %s %s\n";
     50          

   \                                 In section .rodata, align 4
     51          static const int8 SYNTAX[] = 
   \                     SYNTAX:
   \   00000000   0x45 0x72          DC8 "Error: Invalid syntax for: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x73    
   \              0x79 0x6E    
   \              0x74 0x61    
   \              0x78 0x20    
   \              0x66 0x6F    
   \              0x72 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0
     52              "Error: Invalid syntax for: %s\n";
     53          

   \                                 In section .rodata, align 4
     54          static const int8 INVOPT[] = 
   \                     INVOPT:
   \   00000000   0x45 0x72          DC8 "Error:  Invalid set/show option: %s\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x20    
   \              0x49 0x6E    
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x73 0x65    
   \              0x74 0x2F    
   \              0x73 0x68    
   \              0x6F 0x77    
   \              0x20 0x6F    
   \              0x70 0x74    
   \              0x69 0x6F    
   \              0x6E 0x3A    
   \              0x20 0x25    
   \              0x73 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         
     55              "Error:  Invalid set/show option: %s\n";
     56          

   \                                 In section .rodata, align 4
     57          static const int8 OPTFMT[] = 
   \                     OPTFMT:
   \   00000000   0x25 0x31          DC8 "%12s: "
   \              0x32 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0
     58              "%12s: ";
     59          

   \                                 In section .bss, align 4
     60          static int8 cmdline1 [UIF_MAX_LINE];
   \                     cmdline1:
   \   00000000                      DS8 80

   \                                 In section .bss, align 4
     61          static int8 cmdline2 [UIF_MAX_LINE];
   \                     cmdline2:
   \   00000000                      DS8 80
     62          
     63          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
     64          int8 *get_line (int8 *line)
     65          {
   \                     get_line: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
     66              int32 pos;
     67              int32 ch;
     68          
     69              pos = 0;
   \   00000004   0x2500             MOVS     R5,#+0
     70              ch = (int32)in_char();
   \   00000006   0x.... 0x....      BL       in_char
   \   0000000A   0xE01F             B.N      ??get_line_0
     71              while ( (ch != 0x0D /* CR */) &&
     72                      (ch != 0x0A /* LF/NL */) &&
     73                      (pos < UIF_MAX_LINE))
     74              {
     75                  switch (ch)
     76                  {
     77                      case 0x08:      /* Backspace */
     78                      case 0x7F:      /* Delete */
     79                          if (pos > 0)
     80                          {
     81                              pos -= 1;
     82                              out_char(0x08);    /* backspace */
     83                              out_char(' ');
     84                              out_char(0x08);    /* backspace */
     85                          }
     86                          break;
     87                      default:
     88                          if ((pos+1) < UIF_MAX_LINE)
   \                     ??get_line_1: (+1)
   \   0000000C   0x1C69             ADDS     R1,R5,#+1
   \   0000000E   0x2950             CMP      R1,#+80
   \   00000010   0xDA08             BGE.N    ??get_line_2
     89                          {
     90                              if ((ch > 0x1f) && (ch < 0x80))
   \   00000012   0xF1B0 0x0120      SUBS     R1,R0,#+32
   \   00000016   0x2960             CMP      R1,#+96
   \   00000018   0xD204             BCS.N    ??get_line_2
     91                              {
     92                                  line[pos++] = (int8)ch;
   \   0000001A   0x5560             STRB     R0,[R4, R5]
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
     93                                  out_char((int8)ch);
   \   0000001E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000020   0x.... 0x....      BL       out_char
     94                              }
     95                          }
     96                          break;
   \                     ??get_line_2: (+1)
   \   00000024   0xE010             B.N      ??get_line_3
   \                     ??get_line_4: (+1)
   \   00000026   0x0001             MOVS     R1,R0
   \   00000028   0x2908             CMP      R1,#+8
   \   0000002A   0xD001             BEQ.N    ??get_line_5
   \   0000002C   0x297F             CMP      R1,#+127
   \   0000002E   0xD1ED             BNE.N    ??get_line_1
   \                     ??get_line_5: (+1)
   \   00000030   0x2D01             CMP      R5,#+1
   \   00000032   0xDB09             BLT.N    ??get_line_6
   \   00000034   0x1E6D             SUBS     R5,R5,#+1
   \   00000036   0x2008             MOVS     R0,#+8
   \   00000038   0x.... 0x....      BL       out_char
   \   0000003C   0x2020             MOVS     R0,#+32
   \   0000003E   0x.... 0x....      BL       out_char
   \   00000042   0x2008             MOVS     R0,#+8
   \   00000044   0x.... 0x....      BL       out_char
     97                  }
     98                  ch = (int32)in_char();
   \                     ??get_line_6: (+1)
   \                     ??get_line_3: (+1)
   \   00000048   0x.... 0x....      BL       in_char
     99              }
   \                     ??get_line_0: (+1)
   \   0000004C   0x280D             CMP      R0,#+13
   \   0000004E   0xD003             BEQ.N    ??get_line_7
   \   00000050   0x280A             CMP      R0,#+10
   \   00000052   0xD001             BEQ.N    ??get_line_7
   \   00000054   0x2D50             CMP      R5,#+80
   \   00000056   0xDBE6             BLT.N    ??get_line_4
    100              line[pos] = '\0';
   \                     ??get_line_7: (+1)
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x5560             STRB     R0,[R4, R5]
    101              out_char(0x0D);    /* CR */
   \   0000005C   0x200D             MOVS     R0,#+13
   \   0000005E   0x.... 0x....      BL       out_char
    102              out_char(0x0A);    /* LF */
   \   00000062   0x200A             MOVS     R0,#+10
   \   00000064   0x.... 0x....      BL       out_char
    103          
    104              return line;
   \   00000068   0x0020             MOVS     R0,R4
   \   0000006A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    105          }
    106          
    107          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    108          int32 make_argv (int8 *cmdline, int8 *argv[])
    109          {
   \                     make_argv: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x0004             MOVS     R4,R0
    110              int32 argc, i, in_text;
    111          
    112              /* 
    113               * Break cmdline into strings and argv
    114               * It is permissible for argv to be NULL, in which case
    115               * the purpose of this routine becomes to count args
    116               */
    117              argc = 0;
   \   00000004   0x2000             MOVS     R0,#+0
    118              i = 0;
   \   00000006   0x2500             MOVS     R5,#+0
    119              in_text = FALSE;
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xE00D             B.N      ??make_argv_0
    120              while (cmdline[i] != '\0')  /* getline() must place 0x00 on end */
    121              {
    122                  if (((cmdline[i] == ' ')   ||
    123                       (cmdline[i] == '\t')) )
    124                  {
    125                      if (in_text)
   \                     ??make_argv_1: (+1)
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD00A             BEQ.N    ??make_argv_2
    126                      {
    127                          /* end of command line argument */
    128                          cmdline[i] = '\0';
   \   00000010   0x2200             MOVS     R2,#+0
   \   00000012   0x5562             STRB     R2,[R4, R5]
    129                          in_text = FALSE;
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0xE006             B.N      ??make_argv_2
    130                      }
    131                      else
    132                      {
    133                          /* still looking for next argument */
    134                          
    135                      }
    136                  }
    137                  else
    138                  {
    139                      /* got non-whitespace character */
    140                      if (in_text)
    141                      {
    142                      }
    143                      else
    144                      {
    145                          /* start of an argument */
    146                          in_text = TRUE;
    147                          if (argc < UIF_MAX_ARGS)
    148                          {
    149                              if (argv != NULL)
   \                     ??make_argv_3: (+1)
   \   00000018   0x2900             CMP      R1,#+0
   \   0000001A   0xD003             BEQ.N    ??make_argv_4
    150                                  argv[argc] = &cmdline[i];
   \   0000001C   0xEB04 0x0305      ADD      R3,R4,R5
   \   00000020   0xF841 0x3020      STR      R3,[R1, R0, LSL #+2]
    151                              argc++;
   \                     ??make_argv_4: (+1)
   \   00000024   0x1C40             ADDS     R0,R0,#+1
    152                          }
    153                          else
    154                              /*return argc;*/
    155                              break;
    156                      }
    157          
    158                  }
    159                  i++;    /* proceed to next character */
   \                     ??make_argv_2: (+1)
   \   00000026   0x1C6D             ADDS     R5,R5,#+1
   \                     ??make_argv_0: (+1)
   \   00000028   0x5763             LDRSB    R3,[R4, R5]
   \   0000002A   0x2B00             CMP      R3,#+0
   \   0000002C   0xD00A             BEQ.N    ??make_argv_5
   \   0000002E   0x5763             LDRSB    R3,[R4, R5]
   \   00000030   0x2B20             CMP      R3,#+32
   \   00000032   0xD0EB             BEQ.N    ??make_argv_1
   \   00000034   0x5763             LDRSB    R3,[R4, R5]
   \   00000036   0x2B09             CMP      R3,#+9
   \   00000038   0xD0E8             BEQ.N    ??make_argv_1
   \   0000003A   0x2A00             CMP      R2,#+0
   \   0000003C   0xD1F3             BNE.N    ??make_argv_2
   \   0000003E   0x2201             MOVS     R2,#+1
   \   00000040   0x280A             CMP      R0,#+10
   \   00000042   0xDBE9             BLT.N    ??make_argv_3
    160              }
    161              if (argv != NULL)
   \                     ??make_argv_6: (+1)
   \                     ??make_argv_5: (+1)
   \   00000044   0x2900             CMP      R1,#+0
   \   00000046   0xD002             BEQ.N    ??make_argv_7
    162                  argv[argc] = NULL;
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    163              return argc;
   \                     ??make_argv_7: (+1)
   \   0000004E   0xBC30             POP      {R4,R5}
   \   00000050   0x4770             BX       LR               ;; return
    164          }
    165          
    166          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    167          void run_cmd (void)
    168          {
   \                     run_cmd: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB08B             SUB      SP,SP,#+44
    169              /*
    170               * Global array of pointers to emulate C argc,argv interface
    171               */
    172              int32 argc;
    173              int8 *argv[UIF_MAX_ARGS + 1];   /* one extra for null terminator */
    174          
    175              get_line(cmdline1);
   \   00000004   0x....             LDR.N    R0,??DataTable4_3
   \   00000006   0x.... 0x....      BL       get_line
    176          
    177              if (!(argc = make_argv(cmdline1,argv)))
   \   0000000A   0x4669             MOV      R1,SP
   \   0000000C   0x....             LDR.N    R0,??DataTable4_3
   \   0000000E   0x.... 0x....      BL       make_argv
   \   00000012   0x0004             MOVS     R4,R0
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xD108             BNE.N    ??run_cmd_0
    178              {
    179                  /* no command entered, just a blank line */
    180                  strcpy(cmdline1,cmdline2);
   \   00000018   0x....             LDR.N    R1,??DataTable4_4
   \   0000001A   0x....             LDR.N    R0,??DataTable4_3
   \   0000001C   0x.... 0x....      BL       strcpy
    181                  argc = make_argv(cmdline1,argv);
   \   00000020   0x4669             MOV      R1,SP
   \   00000022   0x....             LDR.N    R0,??DataTable4_3
   \   00000024   0x.... 0x....      BL       make_argv
   \   00000028   0x0004             MOVS     R4,R0
    182              }
    183              cmdline2[0] = '\0';
   \                     ??run_cmd_0: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable4_4
   \   0000002E   0x7008             STRB     R0,[R1, #+0]
    184          
    185              if (argc)
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD044             BEQ.N    ??run_cmd_1
    186              {
    187                  int32 i;
    188                  for (i = 0; i < UIF_NUM_CMD; i++)
   \   00000034   0x2500             MOVS     R5,#+0
   \   00000036   0xE000             B.N      ??run_cmd_2
   \                     ??run_cmd_3: (+1)
   \   00000038   0x1C6D             ADDS     R5,R5,#+1
   \                     ??run_cmd_2: (+1)
   \   0000003A   0x....             LDR.N    R0,??DataTable4_5
   \   0000003C   0x6800             LDR      R0,[R0, #+0]
   \   0000003E   0x4285             CMP      R5,R0
   \   00000040   0xDA36             BGE.N    ??run_cmd_4
    189                  {
    190                      if (strcasecmp(UIF_CMDTAB[i].cmd,argv[0]) == 0)
   \   00000042   0x9900             LDR      R1,[SP, #+0]
   \   00000044   0x....             LDR.N    R0,??DataTable4_6
   \   00000046   0x221C             MOVS     R2,#+28
   \   00000048   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000004C   0x5880             LDR      R0,[R0, R2]
   \   0000004E   0x.... 0x....      BL       strcasecmp
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xD1F0             BNE.N    ??run_cmd_3
    191                      {
    192                          if (((argc-1) >= UIF_CMDTAB[i].min_args) &&
    193                              ((argc-1) <= UIF_CMDTAB[i].max_args))
   \   00000056   0x1E60             SUBS     R0,R4,#+1
   \   00000058   0x....             LDR.N    R1,??DataTable4_6
   \   0000005A   0x221C             MOVS     R2,#+28
   \   0000005C   0xFB02 0xF205      MUL      R2,R2,R5
   \   00000060   0x4411             ADD      R1,R1,R2
   \   00000062   0x6849             LDR      R1,[R1, #+4]
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xDB1E             BLT.N    ??run_cmd_5
   \   00000068   0x....             LDR.N    R0,??DataTable4_6
   \   0000006A   0x211C             MOVS     R1,#+28
   \   0000006C   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000070   0x4408             ADD      R0,R0,R1
   \   00000072   0x6880             LDR      R0,[R0, #+8]
   \   00000074   0x1E61             SUBS     R1,R4,#+1
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xDB15             BLT.N    ??run_cmd_5
    194                          {
    195                              if (UIF_CMDTAB[i].flags & UIF_CMD_FLAG_REPEAT)
   \   0000007A   0x....             LDR.N    R0,??DataTable4_6
   \   0000007C   0x211C             MOVS     R1,#+28
   \   0000007E   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000082   0x4408             ADD      R0,R0,R1
   \   00000084   0x7B00             LDRB     R0,[R0, #+12]
   \   00000086   0x07C0             LSLS     R0,R0,#+31
   \   00000088   0xD503             BPL.N    ??run_cmd_6
    196                              {
    197                                  strcpy(cmdline2,argv[0]);
   \   0000008A   0x9900             LDR      R1,[SP, #+0]
   \   0000008C   0x....             LDR.N    R0,??DataTable4_4
   \   0000008E   0x.... 0x....      BL       strcpy
    198                              }
    199                              UIF_CMDTAB[i].func(argc,argv);
   \                     ??run_cmd_6: (+1)
   \   00000092   0x4669             MOV      R1,SP
   \   00000094   0x0020             MOVS     R0,R4
   \   00000096   0x....             LDR.N    R3,??DataTable4_6
   \   00000098   0x221C             MOVS     R2,#+28
   \   0000009A   0x4355             MULS     R5,R2,R5
   \   0000009C   0xEB03 0x0205      ADD      R2,R3,R5
   \   000000A0   0x6912             LDR      R2,[R2, #+16]
   \   000000A2   0x4790             BLX      R2
    200                              return;
   \   000000A4   0xE00B             B.N      ??run_cmd_7
    201                          }
    202                          else
    203                          {
    204                              printf(SYNTAX,argv[0]);
   \                     ??run_cmd_5: (+1)
   \   000000A6   0x9900             LDR      R1,[SP, #+0]
   \   000000A8   0x....             LDR.N    R0,??DataTable4_7
   \   000000AA   0x.... 0x....      BL       printf
    205                              return;
   \   000000AE   0xE006             B.N      ??run_cmd_7
    206                          }
    207                      }
    208                  }
    209                  printf(INVCMD,argv[0]);
   \                     ??run_cmd_4: (+1)
   \   000000B0   0x9900             LDR      R1,[SP, #+0]
   \   000000B2   0x....             LDR.N    R0,??DataTable4_8
   \   000000B4   0x.... 0x....      BL       printf
    210                  printf(HELPMSG);
   \   000000B8   0x....             LDR.N    R0,??DataTable4_9
   \   000000BA   0x.... 0x....      BL       printf
    211              }
    212          }
   \                     ??run_cmd_1: (+1)
   \                     ??run_cmd_7: (+1)
   \   000000BE   0xB00B             ADD      SP,SP,#+44
   \   000000C0   0xBD30             POP      {R4,R5,PC}       ;; return
    213          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    214          uint32 get_value (int8 *s, int32 *success, int32 base)
    215          {
   \                     get_value: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    216              uint32 value;
    217              int8 *p;
    218          
    219              value = strtoul(s,&p,base);
   \   00000006   0x4669             MOV      R1,SP
   \   00000008   0x0020             MOVS     R0,R4
   \   0000000A   0x.... 0x....      BL       strtoul
    220              if ((value == 0) && (p == s))
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD106             BNE.N    ??get_value_0
   \   00000012   0x9900             LDR      R1,[SP, #+0]
   \   00000014   0x42A1             CMP      R1,R4
   \   00000016   0xD103             BNE.N    ??get_value_0
    221              {
    222                  *success = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x6028             STR      R0,[R5, #+0]
    223                  return 0;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xE001             B.N      ??get_value_1
    224              }
    225              else
    226              {
    227                  *success = TRUE;
   \                     ??get_value_0: (+1)
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x6029             STR      R1,[R5, #+0]
    228                  return value;
   \                     ??get_value_1: (+1)
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    229              }
    230          }
    231          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    232          void uif_cmd_help (int32 argc, int8 **argv)
    233          {
   \                     uif_cmd_help: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
    234              int32 index;
    235              
    236              (void)argc;
    237              (void)argv;
    238              
    239              printf("\n");
   \   00000002   0x....             ADR.N    R0,??DataTable4  ;; "\n"
   \   00000004   0x.... 0x....      BL       printf
    240              for (index = 0; index < UIF_NUM_CMD; index++)
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0xE01A             B.N      ??uif_cmd_help_0
    241              {
    242                  printf(HELPFORMAT,
    243                      UIF_CMDTAB[index].cmd,
    244                      UIF_CMDTAB[index].description,
    245                      UIF_CMDTAB[index].cmd,
    246                      UIF_CMDTAB[index].syntax);
   \                     ??uif_cmd_help_1: (+1)
   \   0000000C   0x....             LDR.N    R0,??DataTable4_6
   \   0000000E   0x211C             MOVS     R1,#+28
   \   00000010   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000014   0x4408             ADD      R0,R0,R1
   \   00000016   0x6980             LDR      R0,[R0, #+24]
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x....             LDR.N    R0,??DataTable4_6
   \   0000001C   0x211C             MOVS     R1,#+28
   \   0000001E   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000022   0x5843             LDR      R3,[R0, R1]
   \   00000024   0x....             LDR.N    R0,??DataTable4_6
   \   00000026   0x211C             MOVS     R1,#+28
   \   00000028   0xFB01 0xF104      MUL      R1,R1,R4
   \   0000002C   0x4408             ADD      R0,R0,R1
   \   0000002E   0x6942             LDR      R2,[R0, #+20]
   \   00000030   0x....             LDR.N    R0,??DataTable4_6
   \   00000032   0x211C             MOVS     R1,#+28
   \   00000034   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000038   0x5841             LDR      R1,[R0, R1]
   \   0000003A   0x....             LDR.N    R0,??DataTable4_10
   \   0000003C   0x.... 0x....      BL       printf
    247              }
   \   00000040   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_help_0: (+1)
   \   00000042   0x....             LDR.N    R0,??DataTable4_5
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0x4284             CMP      R4,R0
   \   00000048   0xDBE0             BLT.N    ??uif_cmd_help_1
    248              printf("\n");
   \   0000004A   0x....             ADR.N    R0,??DataTable4  ;; "\n"
   \   0000004C   0x.... 0x....      BL       printf
    249          }
   \   00000050   0xBD13             POP      {R0,R1,R4,PC}    ;; return
    250          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    251          void uif_cmd_set (int32 argc, int8 **argv)
    252          {
   \                     uif_cmd_set: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0005             MOVS     R5,R0
   \   00000004   0x000E             MOVS     R6,R1
    253              int32 index;
    254          
    255              printf("\n");
   \   00000006   0x....             ADR.N    R0,??DataTable4  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    256              if (argc == 1)
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xD11E             BNE.N    ??uif_cmd_set_0
    257              {
    258                  printf("Valid 'set' options:\n");
   \   00000010   0x....             LDR.N    R0,??DataTable4_11
   \   00000012   0x.... 0x....      BL       printf
    259                  for (index = 0; index < UIF_NUM_SETCMD; ++index)
   \   00000016   0x2400             MOVS     R4,#+0
   \   00000018   0xE011             B.N      ??uif_cmd_set_1
    260                  {
    261                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_set_2: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable4_12
   \   0000001C   0x2114             MOVS     R1,#+20
   \   0000001E   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000022   0x5841             LDR      R1,[R0, R1]
   \   00000024   0x....             LDR.N    R0,??DataTable4_13
   \   00000026   0x.... 0x....      BL       printf
    262                      printf("%s\n",UIF_SETCMDTAB[index].syntax);
   \   0000002A   0x....             LDR.N    R0,??DataTable4_12
   \   0000002C   0x2114             MOVS     R1,#+20
   \   0000002E   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000032   0x4408             ADD      R0,R0,R1
   \   00000034   0x6901             LDR      R1,[R0, #+16]
   \   00000036   0x....             ADR.N    R0,??DataTable4_1  ;; "%s\n"
   \   00000038   0x.... 0x....      BL       printf
    263                  }
   \   0000003C   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_1: (+1)
   \   0000003E   0x....             LDR.N    R0,??DataTable4_14
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0x4284             CMP      R4,R0
   \   00000044   0xDBE9             BLT.N    ??uif_cmd_set_2
    264                  printf("\n");
   \   00000046   0x....             ADR.N    R0,??DataTable4  ;; "\n"
   \   00000048   0x.... 0x....      BL       printf
    265                  return;
   \   0000004C   0xE03B             B.N      ??uif_cmd_set_3
    266              }
    267          
    268              if (argc != 3)
   \                     ??uif_cmd_set_0: (+1)
   \   0000004E   0x2D03             CMP      R5,#+3
   \   00000050   0xD003             BEQ.N    ??uif_cmd_set_4
    269              {
    270                  printf("Error: Invalid argument list\n");
   \   00000052   0x....             LDR.N    R0,??DataTable4_15
   \   00000054   0x.... 0x....      BL       printf
    271                  return;
   \   00000058   0xE035             B.N      ??uif_cmd_set_3
    272              }
    273          
    274              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_set_4: (+1)
   \   0000005A   0x2400             MOVS     R4,#+0
   \   0000005C   0xE000             B.N      ??uif_cmd_set_5
   \                     ??uif_cmd_set_6: (+1)
   \   0000005E   0x1C64             ADDS     R4,R4,#+1
   \                     ??uif_cmd_set_5: (+1)
   \   00000060   0x....             LDR.N    R0,??DataTable4_14
   \   00000062   0x6800             LDR      R0,[R0, #+0]
   \   00000064   0x4284             CMP      R4,R0
   \   00000066   0xDA2A             BGE.N    ??uif_cmd_set_7
    275              {
    276                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000068   0x6871             LDR      R1,[R6, #+4]
   \   0000006A   0x....             LDR.N    R0,??DataTable4_12
   \   0000006C   0x2214             MOVS     R2,#+20
   \   0000006E   0xFB02 0xF204      MUL      R2,R2,R4
   \   00000072   0x5880             LDR      R0,[R0, R2]
   \   00000074   0x.... 0x....      BL       strcasecmp
   \   00000078   0x2800             CMP      R0,#+0
   \   0000007A   0xD1F0             BNE.N    ??uif_cmd_set_6
    277                  {
    278                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    279                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   0000007C   0x1EA8             SUBS     R0,R5,#+2
   \   0000007E   0x....             LDR.N    R1,??DataTable4_12
   \   00000080   0x2214             MOVS     R2,#+20
   \   00000082   0xFB02 0xF204      MUL      R2,R2,R4
   \   00000086   0x4411             ADD      R1,R1,R2
   \   00000088   0x6849             LDR      R1,[R1, #+4]
   \   0000008A   0x4288             CMP      R0,R1
   \   0000008C   0xDB12             BLT.N    ??uif_cmd_set_8
   \   0000008E   0x....             LDR.N    R0,??DataTable4_12
   \   00000090   0x2114             MOVS     R1,#+20
   \   00000092   0xFB01 0xF104      MUL      R1,R1,R4
   \   00000096   0x4408             ADD      R0,R0,R1
   \   00000098   0x6880             LDR      R0,[R0, #+8]
   \   0000009A   0x1EA9             SUBS     R1,R5,#+2
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xDB09             BLT.N    ??uif_cmd_set_8
    280                      {
    281                          UIF_SETCMDTAB[index].func(argc,argv);
   \   000000A0   0x0031             MOVS     R1,R6
   \   000000A2   0x0028             MOVS     R0,R5
   \   000000A4   0x....             LDR.N    R3,??DataTable4_12
   \   000000A6   0x2214             MOVS     R2,#+20
   \   000000A8   0x4354             MULS     R4,R2,R4
   \   000000AA   0xEB03 0x0204      ADD      R2,R3,R4
   \   000000AE   0x68D2             LDR      R2,[R2, #+12]
   \   000000B0   0x4790             BLX      R2
    282                          return;
   \   000000B2   0xE008             B.N      ??uif_cmd_set_3
    283                      }
    284                      else
    285                      {
    286                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_set_8: (+1)
   \   000000B4   0x6871             LDR      R1,[R6, #+4]
   \   000000B6   0x....             LDR.N    R0,??DataTable4_16
   \   000000B8   0x.... 0x....      BL       printf
    287                          return;
   \   000000BC   0xE003             B.N      ??uif_cmd_set_3
    288                      }
    289                  }
    290              }
    291              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_set_7: (+1)
   \   000000BE   0x6871             LDR      R1,[R6, #+4]
   \   000000C0   0x....             LDR.N    R0,??DataTable4_17
   \   000000C2   0x.... 0x....      BL       printf
    292          }
   \                     ??uif_cmd_set_3: (+1)
   \   000000C6   0xBD70             POP      {R4-R6,PC}       ;; return
    293          
    294          /********************************************************************/

   \                                 In section .text, align 2, keep-with-next
    295          void uif_cmd_show (int32 argc, int8 **argv)
    296          {
   \                     uif_cmd_show: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0006             MOVS     R6,R0
   \   00000004   0x000C             MOVS     R4,R1
    297              int32 index;
    298          
    299              printf("\n");
   \   00000006   0x....             ADR.N    R0,??DataTable4  ;; "\n"
   \   00000008   0x.... 0x....      BL       printf
    300              if (argc == 1)
   \   0000000C   0x2E01             CMP      R6,#+1
   \   0000000E   0xD121             BNE.N    ??uif_cmd_show_0
    301              {
    302                  /*
    303                   * Show all Option settings
    304                   */
    305                  argc = 2;
   \   00000010   0x2502             MOVS     R5,#+2
    306                  argv[2] = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x60A0             STR      R0,[R4, #+8]
    307                  for (index = 0; index < UIF_NUM_SETCMD; index++)
   \   00000016   0x2600             MOVS     R6,#+0
   \   00000018   0xE014             B.N      ??uif_cmd_show_1
    308                  {
    309                      printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \                     ??uif_cmd_show_2: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable4_12
   \   0000001C   0x2114             MOVS     R1,#+20
   \   0000001E   0xFB01 0xF106      MUL      R1,R1,R6
   \   00000022   0x5841             LDR      R1,[R0, R1]
   \   00000024   0x....             LDR.N    R0,??DataTable4_13
   \   00000026   0x.... 0x....      BL       printf
    310                      UIF_SETCMDTAB[index].func(argc,argv);
   \   0000002A   0x0021             MOVS     R1,R4
   \   0000002C   0x0028             MOVS     R0,R5
   \   0000002E   0x....             LDR.N    R2,??DataTable4_12
   \   00000030   0x2314             MOVS     R3,#+20
   \   00000032   0xFB03 0xF306      MUL      R3,R3,R6
   \   00000036   0x441A             ADD      R2,R2,R3
   \   00000038   0x68D2             LDR      R2,[R2, #+12]
   \   0000003A   0x4790             BLX      R2
    311                      printf("\n");
   \   0000003C   0x....             ADR.N    R0,??DataTable4  ;; "\n"
   \   0000003E   0x.... 0x....      BL       printf
    312                  }
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   \                     ??uif_cmd_show_1: (+1)
   \   00000044   0x....             LDR.N    R0,??DataTable4_14
   \   00000046   0x6800             LDR      R0,[R0, #+0]
   \   00000048   0x4286             CMP      R6,R0
   \   0000004A   0xDBE6             BLT.N    ??uif_cmd_show_2
    313                  printf("\n");
   \   0000004C   0x....             ADR.N    R0,??DataTable4  ;; "\n"
   \   0000004E   0x.... 0x....      BL       printf
    314                  return;
   \   00000052   0xE040             B.N      ??uif_cmd_show_3
    315              }
    316          
    317              for (index = 0; index < UIF_NUM_SETCMD; index++)
   \                     ??uif_cmd_show_0: (+1)
   \   00000054   0x2500             MOVS     R5,#+0
   \   00000056   0xE000             B.N      ??uif_cmd_show_4
   \                     ??uif_cmd_show_5: (+1)
   \   00000058   0x1C6D             ADDS     R5,R5,#+1
   \                     ??uif_cmd_show_4: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable4_14
   \   0000005C   0x6800             LDR      R0,[R0, #+0]
   \   0000005E   0x4285             CMP      R5,R0
   \   00000060   0xDA35             BGE.N    ??uif_cmd_show_6
    318              {
    319                  if (strcasecmp(UIF_SETCMDTAB[index].option,argv[1]) == 0)
   \   00000062   0x6861             LDR      R1,[R4, #+4]
   \   00000064   0x....             LDR.N    R0,??DataTable4_12
   \   00000066   0x2214             MOVS     R2,#+20
   \   00000068   0xFB02 0xF205      MUL      R2,R2,R5
   \   0000006C   0x5880             LDR      R0,[R0, R2]
   \   0000006E   0x.... 0x....      BL       strcasecmp
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD1F0             BNE.N    ??uif_cmd_show_5
    320                  {
    321                      if (((argc-1-1) >= UIF_SETCMDTAB[index].min_args) &&
    322                          ((argc-1-1) <= UIF_SETCMDTAB[index].max_args))
   \   00000076   0x1EB0             SUBS     R0,R6,#+2
   \   00000078   0x....             LDR.N    R1,??DataTable4_12
   \   0000007A   0x2214             MOVS     R2,#+20
   \   0000007C   0xFB02 0xF205      MUL      R2,R2,R5
   \   00000080   0x4411             ADD      R1,R1,R2
   \   00000082   0x6849             LDR      R1,[R1, #+4]
   \   00000084   0x4288             CMP      R0,R1
   \   00000086   0xDB1D             BLT.N    ??uif_cmd_show_7
   \   00000088   0x....             LDR.N    R0,??DataTable4_12
   \   0000008A   0x2114             MOVS     R1,#+20
   \   0000008C   0xFB01 0xF105      MUL      R1,R1,R5
   \   00000090   0x4408             ADD      R0,R0,R1
   \   00000092   0x6880             LDR      R0,[R0, #+8]
   \   00000094   0x1EB1             SUBS     R1,R6,#+2
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xDB14             BLT.N    ??uif_cmd_show_7
    323                      {
    324                          printf(OPTFMT,UIF_SETCMDTAB[index].option);
   \   0000009A   0x....             LDR.N    R0,??DataTable4_12
   \   0000009C   0x2114             MOVS     R1,#+20
   \   0000009E   0xFB01 0xF105      MUL      R1,R1,R5
   \   000000A2   0x5841             LDR      R1,[R0, R1]
   \   000000A4   0x....             LDR.N    R0,??DataTable4_13
   \   000000A6   0x.... 0x....      BL       printf
    325                          UIF_SETCMDTAB[index].func(argc,argv);
   \   000000AA   0x0021             MOVS     R1,R4
   \   000000AC   0x0030             MOVS     R0,R6
   \   000000AE   0x....             LDR.N    R3,??DataTable4_12
   \   000000B0   0x2214             MOVS     R2,#+20
   \   000000B2   0x4355             MULS     R5,R2,R5
   \   000000B4   0xEB03 0x0205      ADD      R2,R3,R5
   \   000000B8   0x68D2             LDR      R2,[R2, #+12]
   \   000000BA   0x4790             BLX      R2
    326                          printf("\n\n");
   \   000000BC   0x....             ADR.N    R0,??DataTable4_2  ;; 0x0A, 0x0A, 0x00, 0x00
   \   000000BE   0x.... 0x....      BL       printf
    327                          return;
   \   000000C2   0xE008             B.N      ??uif_cmd_show_3
    328                      }
    329                      else
    330                      {
    331                          printf(INVARG,argv[1]);
   \                     ??uif_cmd_show_7: (+1)
   \   000000C4   0x6861             LDR      R1,[R4, #+4]
   \   000000C6   0x....             LDR.N    R0,??DataTable4_16
   \   000000C8   0x.... 0x....      BL       printf
    332                          return;
   \   000000CC   0xE003             B.N      ??uif_cmd_show_3
    333                      }
    334                  }
    335              }
    336              printf(INVOPT,argv[1]);
   \                     ??uif_cmd_show_6: (+1)
   \   000000CE   0x6861             LDR      R1,[R4, #+4]
   \   000000D0   0x....             LDR.N    R0,??DataTable4_17
   \   000000D2   0x.... 0x....      BL       printf
    337          }
   \                     ??uif_cmd_show_3: (+1)
   \   000000D6   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     cmdline1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     cmdline2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     UIF_NUM_CMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     UIF_CMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     SYNTAX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     INVCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     HELPMSG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     HELPFORMAT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_12:
   \   00000000   0x........         DC32     UIF_SETCMDTAB

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_13:
   \   00000000   0x........         DC32     OPTFMT

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_14:
   \   00000000   0x........         DC32     UIF_NUM_SETCMD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_15:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_16:
   \   00000000   0x........         DC32     INVARG

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_17:
   \   00000000   0x........         DC32     INVOPT

   \                                 In section .rodata, align 2
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x56 0x61          DC8 "Valid 'set' options:\012"
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x27 0x73    
   \              0x65 0x74    
   \              0x27 0x20    
   \              0x6F 0x70    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x73 0x3A    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x45 0x72          DC8 "Error: Invalid argument list\012"
   \              0x72 0x6F    
   \              0x72 0x3A    
   \              0x20 0x49    
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x61    
   \              0x72 0x67    
   \              0x75 0x6D    
   \              0x65 0x6E    
   \              0x74 0x20    
   \              0x6C 0x69    
   \              0x73 0x74    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \   00000000   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \   00000003   0x00               DC8 0
    338          
    339          /********************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   get_line
        16   -> in_char
        16   -> out_char
      16   get_value
        16   -> strtoul
       8   make_argv
      56   run_cmd
        56   -- Indirect call
        56   -> get_line
        56   -> make_argv
        56   -> printf
        56   -> strcasecmp
        56   -> strcpy
      16   uif_cmd_help
        16   -> printf
      16   uif_cmd_set
        16   -- Indirect call
        16   -> printf
        16   -> strcasecmp
      16   uif_cmd_show
        16   -- Indirect call
        16   -> printf
        16   -> strcasecmp


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       2  ?_0
      24  ?_1
       4  ?_2
      32  ?_3
       4  ?_4
      20  HELPFORMAT
      24  HELPMSG
      28  INVALUE
      32  INVARG
      28  INVCMD
      40  INVOPT
       8  OPTFMT
      32  SYNTAX
      80  cmdline1
      80  cmdline2
     108  get_line
      38  get_value
      82  make_argv
     194  run_cmd
      82  uif_cmd_help
     200  uif_cmd_set
     216  uif_cmd_show

 
 160 bytes in section .bss
 278 bytes in section .rodata
 992 bytes in section .text
 
 992 bytes of CODE  memory
 278 bytes of CONST memory
 160 bytes of DATA  memory

Errors: none
Warnings: none
